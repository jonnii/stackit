package actions

import (
	"fmt"
	"strings"

	"stackit.dev/stackit/internal/engine"
)

const (
	footerTitle  = "\n\n\n#### PR Dependency Tree\n\n"
	footerFooter = "\n\nThis tree was auto-generated by [Stackit](https://github.com/jonnii/stackit)"
)

// CreatePRBodyFooter creates a PR body footer with dependency tree
func CreatePRBodyFooter(branch string, eng engine.Engine) string {
	terminalParent := findTerminalParent(branch, eng)

	var tree strings.Builder
	for branchName, depth := range eng.BranchesDepthFirst(terminalParent) {
		// Only include branches related to the PR branch
		if branchName != branch && !isParentOrChild(eng, branchName, branch) {
			continue // skip but continue traversal
		}

		leaf := buildLeaf(eng, branchName, depth, branch)
		if leaf != "" {
			tree.WriteString(leaf)
		}
	}

	return footerTitle + tree.String() + footerFooter
}

// UpdatePRBodyFooter updates an existing PR body with a new footer
func UpdatePRBodyFooter(existingBody, footer string) string {
	if existingBody == "" {
		return footer
	}

	// Check if footer already exists
	if strings.Contains(existingBody, footerTitle) {
		// Replace existing footer
		titleIndex := strings.Index(existingBody, footerTitle)
		if titleIndex >= 0 {
			// Find the end of the footer (before footerFooter)
			footerEnd := strings.Index(existingBody[titleIndex:], footerFooter)
			if footerEnd >= 0 {
				// Replace from title to end of footer
				return existingBody[:titleIndex] + footer
			}
		}
	}

	// Append footer if it doesn't exist
	return existingBody + footer
}

// findTerminalParent finds the terminal parent (parent of trunk) for a branch
func findTerminalParent(currentBranch string, eng engine.BranchReader) string {
	parent := eng.GetParent(currentBranch)
	if parent == "" {
		// No parent, use trunk
		return eng.Trunk()
	}

	parentBranch := eng.GetBranch(parent)
	if parentBranch.IsTrunk() {
		return currentBranch
	}

	return findTerminalParent(parent, eng)
}

// buildLeaf builds a single leaf in the tree
func buildLeaf(eng engine.PRManager, branch string, depth int, prBranch string) string {
	prInfo, err := eng.GetPrInfo(branch)
	if err != nil || prInfo == nil || prInfo.Number == nil {
		return ""
	}

	indent := strings.Repeat("  ", depth)
	marker := ""
	if branch == prBranch {
		marker = " ðŸ‘ˆ"
	}

	return fmt.Sprintf("\n%s* **PR #%d**%s", indent, *prInfo.Number, marker)
}

// isParentOrChild checks if branch1 is a parent or child of branch2
func isParentOrChild(eng engine.BranchReader, branch1, branch2 string) bool {
	visited := make(map[string]bool)
	return isParentOrChildRecursive(eng, branch1, branch2, visited)
}

// isParentOrChildRecursive is the recursive helper with cycle detection
func isParentOrChildRecursive(eng engine.BranchReader, branch1, branch2 string, visited map[string]bool) bool {
	// Prevent infinite recursion
	if visited[branch1] {
		return false
	}
	visited[branch1] = true

	// Check if branch1 is parent of branch2
	children := eng.GetChildren(branch1)
	for _, child := range children {
		if child == branch2 {
			return true
		}
		if isParentOrChildRecursive(eng, child, branch2, visited) {
			return true
		}
	}

	// Check if branch1 is child of branch2
	parent := eng.GetParent(branch1)
	if parent == branch2 {
		return true
	}
	if parent != "" {
		return isParentOrChildRecursive(eng, parent, branch2, visited)
	}

	return false
}
