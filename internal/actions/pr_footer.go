package actions

import (
	"context"
	"fmt"
	"strings"

	"stackit.dev/stackit/internal/engine"
)

const (
	footerTitle  = "\n\n\n#### PR Dependency Tree\n\n"
	footerFooter = "\n\nThis tree was auto-generated by [Stackit](https://github.com/jonnii/stackit)"
)

// CreatePRBodyFooter creates a PR body footer with dependency tree
func CreatePRBodyFooter(ctx context.Context, branch string, eng engine.Engine) string {
	terminalParent := findTerminalParent(branch, eng)

	tree := buildBranchTree(ctx, eng, []string{terminalParent}, branch, 0)

	return footerTitle + tree + footerFooter
}

// UpdatePRBodyFooter updates an existing PR body with a new footer
func UpdatePRBodyFooter(existingBody, footer string) string {
	if existingBody == "" {
		return footer
	}

	// Check if footer already exists
	if strings.Contains(existingBody, footerTitle) {
		// Replace existing footer
		titleIndex := strings.Index(existingBody, footerTitle)
		if titleIndex >= 0 {
			// Find the end of the footer (before footerFooter)
			footerEnd := strings.Index(existingBody[titleIndex:], footerFooter)
			if footerEnd >= 0 {
				// Replace from title to end of footer
				return existingBody[:titleIndex] + footer
			}
		}
	}

	// Append footer if it doesn't exist
	return existingBody + footer
}

// findTerminalParent finds the terminal parent (parent of trunk) for a branch
func findTerminalParent(currentBranch string, eng engine.BranchReader) string {
	parent := eng.GetParent(currentBranch)
	if parent == "" {
		// No parent, use trunk
		return eng.Trunk()
	}

	if eng.IsTrunk(parent) {
		return currentBranch
	}

	return findTerminalParent(parent, eng)
}

// buildBranchTree builds a tree representation of branch dependencies
func buildBranchTree(ctx context.Context, eng engine.Engine, currentBranches []string, prBranch string, currentDepth int) string {
	var tree strings.Builder

	for _, branch := range currentBranches {
		if branch != prBranch && !isParentOrChild(eng, branch, prBranch) {
			continue
		}

		leaf := buildLeaf(ctx, eng, branch, currentDepth, prBranch)
		if leaf != "" {
			tree.WriteString(leaf)
		}

		children := eng.GetChildren(branch)
		if len(children) > 0 {
			childTree := buildBranchTree(ctx, eng, children, prBranch, currentDepth+1)
			tree.WriteString(childTree)
		}
	}

	return tree.String()
}

// buildLeaf builds a single leaf in the tree
func buildLeaf(ctx context.Context, eng engine.PRManager, branch string, depth int, prBranch string) string {
	prInfo, err := eng.GetPrInfo(ctx, branch)
	if err != nil || prInfo == nil || prInfo.Number == nil {
		return ""
	}

	indent := strings.Repeat("  ", depth)
	marker := ""
	if branch == prBranch {
		marker = " ðŸ‘ˆ"
	}

	return fmt.Sprintf("\n%s* **PR #%d**%s", indent, *prInfo.Number, marker)
}

// isParentOrChild checks if branch1 is a parent or child of branch2
func isParentOrChild(eng engine.BranchReader, branch1, branch2 string) bool {
	visited := make(map[string]bool)
	return isParentOrChildRecursive(eng, branch1, branch2, visited)
}

// isParentOrChildRecursive is the recursive helper with cycle detection
func isParentOrChildRecursive(eng engine.BranchReader, branch1, branch2 string, visited map[string]bool) bool {
	// Prevent infinite recursion
	if visited[branch1] {
		return false
	}
	visited[branch1] = true

	// Check if branch1 is parent of branch2
	children := eng.GetChildren(branch1)
	for _, child := range children {
		if child == branch2 {
			return true
		}
		if isParentOrChildRecursive(eng, child, branch2, visited) {
			return true
		}
	}

	// Check if branch1 is child of branch2
	parent := eng.GetParent(branch1)
	if parent == branch2 {
		return true
	}
	if parent != "" {
		return isParentOrChildRecursive(eng, parent, branch2, visited)
	}

	return false
}
